面试题：https://blog.csdn.net/weixin_42060900/article/details/96503788

1.字节对齐
	概念：计算机系统对基本数据类型合法地址做出限制，某种类型对象的地址必须是某个值（2，4，8）的倍数，可以简化处理器和存储器系统之间的接口的硬件设计。
	字节对齐：根本原因在于提升CPU访问数据的效率
	处理字节对齐
		1.基本数据类型自身对齐值：指定为平台的基本数据类型的长度，如char-1,short-2
		2.结构体或类的自身对齐值：其成员中自身对齐值最大的那个
		3.指定对齐值：#pragma pack(value)时的指定对齐值
		4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中最小的那个
			数组：按基本数据类型对齐，第一个对齐后面自然对齐
			联合：按包含的长度最大的数据类型对齐
			结构体：结构体中每个数据类型都要对齐
	结构体字节对齐(http://c.biancheng.net/view/243.html)
		结构体：一种构造数据类型，内部可以有不同的数据类型
		结构体按照字节对齐存储，即以结构体成员占内存最多的数据类型所占字节数为标准，同时如果剩下的空间不足以填充某成员变量，即剩下的空间小于某成员变量数据类型所占的字节数，则该成员变量分配内存另起一行分配。
		举例：
			struct STUDENT {
				char a;
				char b;
				char c;
				char d;
				char e;
				int f;
			}
			int数据类型占内存最多，为标准4，char占一个字节，因此前四个char型放一行，第五个e空间不足，另起一行，后三字节使用-1或什么的填充，因此总共是12字节
			char[10]数组的话可看成10个char型，其他与上同
			
2.数组
	概念：分配一块连续的内存空间存储一组类型相同的数据集合，内存连续-元素之间相互挨着，通过指针访问数组元素和内存处理(整块内存的复制、写入等)提供便利
	可以通过下标获取数组中的值a[2],&a[2]是获取对应数组值的地址
	数组定义：
		int a[4];
	数组初始化：
		int[4] = {1,2,3,,4};
		int[] = {1,2,3,4};
		int[4] = {1,2};  //剩余元素会自动初始化为0，char-'\0',float和double是{0.0}
	数组名地址：
		eg:int a[4] = {0};
		&a是整个数组的首地址，a是数组首元素的首地址(和&array[0]一样)
		a+1就是a[1]的地址，&a+1就是增加4个int类型字节的长度了
		数组名的值是个指针常量，也就是数组第一个元素的地址，类型取决于指向数组元素的类型，如果是int类型，那么数组名的类型就是“指向int的常量指针”
		sizeof:返回一个对象或类型所占的内存字节数
		sizeof(数组名)：就是整个数组的长度
		sizeof(*数组名)：就是指针的大小		指针大小都是占用四个字节
		
3.野指针
	nullptr：NULL在C++中是0，nullptr在任何情况下都可以代表空指针
	
4.const指针
	定义：const是指针变量的值一经初始化就不可以改变
	const可放在类型的前后，关键是看const的右边来确定是什么被声明为常量，如果是类型，则值是常量，即它指向的值不能改变，如果是指针变量，则指针本身是常量，即常量指针，不能指向别的值，但指向的值可以修改
	例：const int * p;// 右边是类型，指向整形常量的指针，值不可改变
		int * const p;// 右边是指针，指向整形的常量指针，不能指向别的变量
		const int * const p;// 指向整形常量的常量指针，不能指向别的值，指向的值也不能修改
	const成员函数：如果试图修改对象数据，编译器将报错
			
5.volatile关键字
	表示一个变量也许会被后台程序改变，这种方式按照正常流程是无法预知的
	变量加了volatile修饰，则会从内存重新装载内容，而不是从寄存器中拷贝内容(编译期间)
		如在Release模式下，编译器可能会对程序进行优化，比如将部分值存入寄存器，后续使用可能直接从寄存器读取，寄存器读取速度要大于内存，使用volatile后会直接从内存中读取数据
	作为指令关键字，确保本条指令不会因为编译器的优化而省略，且要求每次直接读值
	牵扯到中断、底层硬件

6.inline关键字
	内联函数：目的是提高函数的执行效率，使用inline关键字定义(关键字需放在函数定义前，而不是声明)
		通常是将它在程序中每个调用点“内联的”展开
		内联函数能够进行调试和操作类的私有成员
		在调用内联函数时，编译器首先会进行类型安全检查或者自动类型转换如果正确就会直接替换函数调用语句，于是省去了函数调用的开销，预处理器无法做到，函数内联后，编译器通过上下文相关优化可度代码执行进行更深化的优化
	内联的优缺点：
		内联是以代码膨胀(拷贝)为代价，消耗内存空间，省去了函数调用(指参数压栈、跳转、退栈、返回等操作)的开销，从而提高程序的执行效率，如果执行函数体代码时间比函数调佣的开销大很多，那么inline的效率收益会很小
		不适合使用内联：函数体内代码长，函数体内出现循环或者其他复杂控制结构(如循环或 switch 语句)
		适合内联：函数只有10行或者更少
		
7.extern关键字
	两个作用
		第一个作用：当与"C"连用时，如extern "C" void fun(int a,int b);告诉编译器在编译fun函数名时按照C的规则去翻译，在CPP文件中include C头文件时，需要使用extern "C",如extern "C" { #include "b.h"},这里b.h是一个C头文件，而不是CPP头文件
		第二个作用：可以让编译器把“寻找定义”这件事推迟到链接阶段，而不是编译阶段，不会在编译阶段报"没有定义"的错误
			用到未定义的变量/函数，一般是使用其他文件中定义的变量/函数，如在a.cpp文件中使用b.cpp中定义的变量/函数		//b.h--->extern b	//b.cpp--->#include <b.h>  int b = 5;	//a.cpp--->#include <b.h>  int main(){	int a=b+1;}
		volatile作用是防止变量被编译器优化，作用于编译阶段
		extern作用是在链接阶段 
		

			
		

		
